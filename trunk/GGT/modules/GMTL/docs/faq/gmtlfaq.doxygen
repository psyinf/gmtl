/** @file gmtlfaq.doxygen
  *
  */

/** @mainpage Generic Math Template Library FAQ
 *  Welcome to the GMTL frequently asked questions list.
 *
 *
 * 
 *
 *  @section General General Questions about GMTL
 *
 *  <b>Why do you use templated code?</b>
 *
 *
 *
 *
 *  <b>What's with these namespaces?</b>
 *  
 *
 *
 *
 *  <b>Why would I want to use GMTL's C math abstraction rather than the regular 
 *  C math headers?</b>
 *  
 *
 *
 *
 *  <b>What is an AABox?</b>
 *  This is an axially-aligned bounding box. Think of it as a box in 3D space
 *  with its each of its sides parallel to one of the coordinate axes. Such a
 *  box can be described using only 2 points, the minimum and maximum. AABoxes
 *  can be useful in object collision detection.
 *
 *  <b>What is an AxisAngle?</b>
 *  This is a rotational data type, defined by an arbitrary axis vector in 
 *  space and an amount of rotation. 
 *
 *  <b>What is a Coord?</b>
 *  This is a coordinate frame, defined by a position and a rotation value. 
 *  
 *  <b>What is an EulerAngle?</b>
 *  This is a data type that represents a rotational value. It consists of three
 *  values, each representing a rotation about one of the coordinate axes X, Y,
 *  and Z. Note that Euler angle representations are often more intuitive to
 *  use, but suffer from the problem of Gimble lock.
 *
 *  <b>What is a Matrix?</b>
 *  This is a data type commonly used in graphical applications. It simply
 *  contains rows and columns of data, with any number of rows and columns.
 *  4x4 matrices can represent any transformation in 3D space, containing
 *  (but not limited to) translational, rotational, skew, and scaling 
 *  information.
 *
 *  <b>What is a Plane?</b>
 *  A plane is a flat surface in 3D space with no boundaries. It is defined by
 *  a point in 3D space and a surface normal vector.
 *
 *  <b>What is a Point?</b>
 *  Points represent a position in space, with one data value per dimension of
 *  that space. 
 *
 *  <b>What is a Quat?</b>
 *  This is a quaternion, which is represents a rotation in 3D space.
 *  Quaternions can be used for rotational interpolation along the surface
 *  of a sphere. They are represented at a 4-element normalized vector.
 *
 *  <b>What is a Sphere?</b>
 *  This is a 3D dimensional round object such that every point on the outer
 *  boundary of the object is the same distance away from the centerpoint. A
 *  sphere can be described by a centerpoint position and a radius.
 *
 *  <b>What is a Tri?</b>
 *  This is a triangle, defined by three points in space. The counterclockwise
 *  ordering of the points determines the direction of the triangle's surface
 *  normal (using a right-handed coordinate system). 
 *
 *  <b>What is a Vec?</b>
 *  This is a vector that represents a direction in space, with one data value
 *  per dimension of the space.
 *
 *  <b>What is the difference between a point and a vector?</b>
 *  Points represent positions in space, while vectors represent a direction.
 *  Even though they may seem to represent the same data, it is generally 
 *  discouraged to use them interchangably. Differences occur when operations
 *  are performed on them. For instance, if you transform a point using a 
 *  matrix, the full transformation will be applied to the point (translation,
 *  rotation, skew, and scale). But when a vector is transformed by a matrix,
 *  only the rotational transform is applied to it.
 *
 *  <b>Why doesn't my vector move?</b>
 *  If you are transforming a vector using a matrix, only the matrix's 
 *  rotational information will be applied. Hence, you may be expecting the
 *  vector's endpoint to change but it will not. You most likely want to use
 *  a Point object instead of a Vec.
 *
 *  <b>What is the difference between AxisAngle, EulerAngle and Quat?</b>
 *  An axis angle consists of a vector designating the axis to rotate about,
 *  and the rotation amount to use. 
 *  An Euler angle object consists of 3 rotation amounts, one for each
 *  coordinate axis X, Y, and Z. Euler angles are often the most intuitive
 *  rotation type, but suffer from the Gimble lock problem.
 *  A quaternion has 4 values that can be translated into an axis and a
 *  rotation amount, but are stored in a normalized form that maintain the
 *  mathematical properties of quaternions, including the ability of spherical
 *  interpolation.  
 *  
 *  <b>How is data represented in a matrix?</b>
 *  GMTL matrices are represented in the same way that OpenGL represents data
 *  in a matrix, in column major order. 
 *
 *  @section Howto How Do I ...?
 *
 *  @subsection Vectors Vectors
 *  <b>How do I rotate a vector?</b>
 *  In most cases you can simply use the * operator with your vector and one of
 *  the rotaional data types.
 *  
 *  gmtl::Vec3f myVec;
 *  gmtl::AxisAngle myAA;
 *  gmtl::Quaternion myQuat;
 *  gmtl::Matrix44f myMat;
 *  gmtl::EulerAngleXYZf myEuler;
 * 
 *  myVec = myVec * myAA;
 *  myVec = myVec * myQuat;
 *  myVec = myVec * myMat;
 *  myVec = myVec * myEuler;
 *
 *
 *  <b>How do I find the cross product of 2 vectors?</b>
 *  We can use the cross function, which returns another vector.
 *
 *  gmtl::Vec3f vecA, vecB, crossVec;
 *  crossVec = gmtl::cross( vecA, vecB );
 *
 * 
 *  <b>How do I find the dot product of 2 vectors?</b>
 *  Use the dot function, which returns a number (depending on the type of
 *  data in the vectors). 
 * 
 *  gmtl::Vec3d vecA, vecB;
 *  double x = gmtl::dot( vecA, vecB );
 *
 *
 *  <b>How do I check if a vector is normalized?</b> 
 *  Use the isNormalized function, which returns a boolean value.
 *
 *  gmtl::Vec3f myVec;
 *  if ( gmtl::isNormalized( myVec ) )
 *  {
 *     cout << "Vector is normalized" << endl;
 *  }
 *  
 *
 *  <b>How do I normalize a vector?</b>
 *  Use the normalize function. After this, the length of the vector will be
 *  1, unless the original length was 0, in which case normalization is not
 *  possible.
 *
 *  gmtl::Vec3f myVec;
 *  gmtl::normalize( myVec );
 *
 *
 *  <b>How do I check if 2 vectors are equal?</b>
 *  Use the == operator, just as you would when testing the equality of simple
 *  data types like `int'.
 *  
 *  gmtl::Vec3f vecA, vecB;
 *  if ( vecA == vecB )
 *  {
 *     cout << "Vectors are equal" << endl;
 *  }
 *
 *
 *  <b>How do I find the length of a vector?</b>
 *  Use the length function. The numeric type returned depends on the data type
 *  of the vector.
 *
 *  gmtl::Vec3f myVec;
 *  float length = gmtl::length( myVec );
 *
 *  Another potential function to use is lengthSquared. This function is
 *  provided as a convenience because GMTL users frequently need this value
 *  rather than merely the length.
 *
 *  float lengthSq = gmtl::lengthSquared( myVec );
 *
 *
 *  <b>How do I invert a vector?</b>
 *  Use A scalar multiplication by -1. This will cause the vector to be 
 *  pointing in the exact opposite direction and keep the same length.
 *
 *  gmtl::Vec3f myVec;
 *  myVec *= -1;
 *
 *
 *  <b>How do I interpolate between 2 vectors?</b>
 *  Use the lerp function. This will perform a linearly-interpolated vector
 *  based on 2 original vectors and an interpolation weight between 0 and 1.
 *
 *  gmtl::Vec3f resultVec, vecA. vecB;
 *  float weight = 0.333;
 *
 *  gmtl::lerp( resultVec, weight, vecA, vecB );
 *
 *  After this function, resultVec now contains a vector that is one third of
 *  the way from vecA to vecB. This resulting vector is closer to vecA.
 *
 *
 *  <b>How do I multiply a vector by a scalar value?</b>
 *  Simply use the * or *= operator.
 *
 *  gmtl::Vec3f myVec, anotherVec;
 *  float myScalar = 3.5;
 *
 *  myVec *= myScalar;
 *  anotherVec = myVec * myScalar;
 *
 *
 *  <b>How do I add, subtract, divide and multiply vectors?</b>
 *  Generally, you can use any of the standard mathematical operators
 *  ('+', '-', '*', '/') to perform math functions on vectors.
 *
 *  gmtl::Vec3f vecA, vecB, vecC;
 *
 *  vecA = vecB * vecC;
 *  vecA = vecB / vecC;
 *  vecA += vecB;
 *  vecA = vecB + vecC;
 *  vecA -= vecC;
 *  vecA = vecB - vecC;
 *  etc.
 *
 *
 *
 *
 *
 *  @subsection Matrices Matrices
 *  <b>How do I multiply matrices?</b>
 *  The simplest way to multiply one matrix by another is to use the * operator.
 *
 *  gmtl::Matrix44f A, B, C;
 *  A = B * C;
 *
 *  Note that when multiplying matrices, the ordering matters. The following
 *  line of code could make matrix A have a different result:
 *
 *  A = C * B;
 *
 *  Alternatively, you can use the preMult and postMult functions. 
 *
 *  This preMult call is the same as "A = B * A;"
 *  gmtl::preMult( A, B ); 
 *
 *  This postMult call is the same as "A = A * B;"
 *  gmtl::postMult( A, B );
 *  
 *  The *= operator also acts as a postMult function.
 *  A *= B;
 *
 *
 *  <b>How do I create a matrix?</b>
 *  You can create a new matrix simply by instantiating it. You can use one of
 *  the GMTL-provided type definitions. The first matrix is a 4x4 matrix of 
 *  floating point numbers. The second is a 2x3 matrix of double precision
 *  floating point numbers. 
 *
 *  gmtl::Matrix44f myMat;
 *  gmtl::Matrix23d otherMat;
 * 
 *  You can also create matrices of arbitrary size and data type using the
 *  templated constructor. The templated arguments are (in order) the data type,
 *  the number of rows, and the number of columns. For example, the following 
 *  creates a 4x6 matrix of floating point numbers.
 *  
 *  gmtl::Matrix< float, 4, 6 > newMatrix;
 *
 *  You can also create a matrix from any of the other transformation data
 *  types. See below for examples.
 *
 *
 *  <b>How do I create a matrix from a vector?</b>
 *  Using the makeTrans function, you can create a purely translational matrix 
 *  from a vector. 
 *
 *  gmtl::Vec3f myVec;
 *  gmtl::Matrix44f myMat = gmtl::makeTrans< gmtl::Matrix44f >( myVec );
 *
 *
 *  <b>How do I create a matrix from a point?</b>
 *  Using the make function, you can create a purely translational matrix from a
 *  point. 
 *
 *  gmtl::Point3f myPoint;
 *  gmtl::Matrix44f myMat = gmtl::make< gmtl::Matrix44f >( myPoint );
 *
 *
 *  <b>How do I create a matrix from a quaterion?</b>
 *  Using the make function, you can create a purely rotational matrix from a
 *  quaternion object. 
 *
 *  gmtl::Quatf myQuat;
 *  gmtl::Matrix44f myMat = gmtl::make< gmtl::Matrix44f >( myQuat );
 *
 *
 *  <b>How do I create a matrix from an Euler angle?</b>
 *  Using the make function, you can create a purely rotational matrix from an
 *  EulerAngle object. 
 *
 *  gmtl::EulerAngleXYZf myEulerAngle;
 *  gmtl::Matrix44f myMat = gmtl::make< gmtl::Matrix44f >( myEulerAngle );
 *
 *
 *
 *  <b>How do I create a matrix from an axis angle?</b>
 *  Using the make function, you can create a purely rotational matrix from an
 *  AxisAngle object. 
 *
 *  gmtl::AxisAnglef myAxisAngle;
 *  gmtl::Matrix44f myMat = gmtl::make< gmtl::Matrix44f >( myAxisAngle );
 *
 *
 *  <b>How do I scale a matrix?</b>
 *  gmtl::Matrix44f myMat;
 *  float scale = 0.5;
 *
 *  gmtl::setScale( myMat, scale );
 *
 *
 *  <b>How do I copy a matrix?</b>
 *  You can simply use the '=' operator to copy from one matrix to another.
 * 
 *  gmtl::Matrix44f matA, matB;
 *  matA = matB;
 *
 *
 *  <b>How do I access individual data elements of a matrix?</b>
 *  You can simply use the [ row# ][ column# ] operators, just as you would 
 *  if you were accessing elements of a double array.
 *
 *  gmtl::Matrix44f myMat;
 *  float x = myMat[3][2];
 *
 *  
 *  <b>How do I extract just the rotation data from a matrix?</b>
 *  You can extract the rotational data as any of GMTL's rotation data types.
 *  In any case, you need to use the makeRot templated function. Note that you
 *  need to specify which rotation data type you want to extract.
 *
 *  gmtl::Matrix44f myMat;
 *  gmtl::EulerAngleXYZf myEuler;
 *  gmtl::AxisAnglef myAxisAngle;
 *  gmtl::Quatf myQuat;
 *  gmtl::Matrix44f myRotationMat;
 *
 *  myEuler = gmtl::makeRot< gmtl::EulerAngleXYZf >( myMat );
 *  myAxisAngle = gmtl::makeRot< gmtl::AxisAnglef >( myMat );
 *  myQuat = gmtl::makeRot< gmtl::Quatf >( myMat );
 *  myRotationMat = gmtl::makeRot< gmtl::EulerAngleXYZf >( myMat );
 *
 * 
 *  <b>How do I extract just the translation data from a matrix?</b>
 *  You can extract the translational data as either a vector or a point.
 *  You need to use the templated makeTrans function.
 *
 *  gmtl::Matrix44f myMat;
 *  gmtl::Point3f myPoint;
 *  gmtl::Vec3f myVec;
 * 
 *  myVec = gmtl::makeTrans< gmtl::Vec3f >( myMat );
 *  myPoint = gmtl::makeTrans< gmtl::Point3f >( myMat );
 *
 *
 *  <b>How do I set a matrix to be the identity matrix?</b>
 *  Matrices will automatically be identity matrices upon creation. If you
 *  want to set them to the identity later, use the identity function.
 *  
 *  gmtl::Matrix44f myMat;
 *  gmtl::identity( myMat );
 *
 *
 *  <b>How do I set a matrix to contain all zeros?</b>
 *  gmtl::Matrix44f myMat;
 *  gmtl::zero( myMat );
 *
 * 
 *  <b>How do I invert a matrix?</b>
 *  In most cases you can simply use the invert function. This will perform a
 *  "smart" inversion that selects an inversion method (full, affine, 
 *  orthonormal, orthogonal, or identity) based on the kinds of transformations
 *  it has been through.
 * 
 *  gmtl::Matrix44f myMat;
 *  gmtl::invert( myMat );
 *
 *  You can optionally force a full inversion by using the invertFull function.
 * 
 *  gmtl::invertFull( myMat );
 *
 *
 *  <b>How do I transpose a matrix?</b>
 *  Use the transpose function.
 *
 *  gmtl::Matrix44f myMat;
 *  gmtl::transpose( myMat );
 * 
 *
 *  <b>How do I transform a point using a matrix?</b>
 *  This will perform a full transformation on the point.
 *
 *  gmtl::Point3f myPoint;
 *  gmtl::Matrix44f myMat;
 *  gmtl::xform( myPoint, myMat, myPoint );
 *
 *
 *  <b>How do I transform a vector using a matrix?</b>
 *  It is important to note that a vector will only be modified by the
 *  rotational transformation contained in a matrix.
 *
 *  gmtl::Vec3f myVec;
 *  gmtl::Matrix44f myMat;
 *  gmtl::xform( myVec, myMat, myVec ); 
 *
 *
 *
 *  <b>How do I use my matrix data with OpenGL?</b>
 *  You can access the raw matrix data for use with OpenGL using the getData()
 *  function.  For instance, you may want to multiply the OpenGL matrix stack
 *  by a GMTL matrix.
 *  
 *  gmtl::Matrix44f myMat;
 *  glMultMatrixf( myMat.getData() );
 *
 *
 *  <b>How do I use my matrix data with DirectX?</b>
 *
 *
 *
 *
 *
 *
 *  @subsection Quaternions Quaternions
 *  <b>How do I create quaternions?</b>
 *  You can create quaternions directly using known values.
 * 
 *  float x = 1.0;
 *  float y, z, w = 0.0;
 *  gmtl::Quatf myQuat(x, y, z, w);
 *
 *  You can also create quaternions based on other rotational types, such
 *  as an EulerAngle or matrix.
 *  
 *  gmtl::EulerAngleXYZf myEuler;
 *  gmtl::Matrix44f myMat;
 *  myQuat = gmtl::make<gmtl::Quatf>( myEuler );
 *  myQuat = gmtl::make<gmtl::Quatf>( myMat );
 *
 *
 *  <b>How do I multiply quaternions?</b>
 *  Simply use the * and *= operators.
 *
 *  gmtl::Quatf quatA, quatB, quatC;
 *  quatA *= quatB;
 *  quatC = quatA * quatB;
 *
 *
 *  <b>How do I combine quaternion rotations?</b>
 *  This is the same as multiplying quaternions.
 *
 *  gmtl::Quatf quatA, quatB, quatC;
 *  quatA *= quatB;
 *  quatC = quatA * quatB;
 *
 *
 *  <b>How do I perform spherical interpolation with quaternions?</b>
 *  Use the slerp function. You need an origin quaternion, a target quaternion,
 *  and an interpolation amount between 0 and 1. The following example 
 *  interpolated halfway between the origin and target quaternions. Note that
 *  the interpolation path follows the shortest length arc around a sphere.
 *
 *  gmtl::Quatf resultQuat, originQuat, targetQuat;
 *  float amount = 0.5;
 *
 *  gmtl::slerp( resultQuat, amount, originQuat, targetQuat );
 *
 *
 *  <b>How do I perform linear interpolation with quaternions?</b>
 *  This is similar to performing spherical interpolation, but follows a 
 *  straight line interpolation path rather than a shortest arc around a sphere.
 *  
 *  gmtl::Quatf resultQuat, originQuat, targetQuat;
 *  float amount = 0.5;
 *
 *  gmtl::lerp( resultQuat, amount, originQuat, targetQuat );
 *  
 *
 *  <b>How do I make a quaternion that rotates one vector to another along the shortest arc?</b>
 *  If you have an origin vector and a target vector, you can use the makeRot 
 *  function. Note that you should normalize these vectors first.
 * 
 *  gmtl::Vec3f originVec, targetVec;
 *  gmtl::Quatf myQuat;
 *
 *  gmtl::normalize( originVec );
 *  gmtl::normalize( targetVec );
 *  myQuat = gmtl::makeRot<gmtl::Quatf>( originVec, targetVec );
 *
 *
 *  <b>How do I invert a quaternion?</b>
 *  Use the invert function. 
 *
 *  gmtl::Quatf myQuat;
 *  gmtl::invert( myQuat );
 *
 *
 *  <b>How do I conjugate a quaternion?</b>
 *  Use the conj function.
 * 
 *  gmtl::Quatf myQuat;
 *  gmtl::conj( myQuat );
 *
 *
 *  <b>How do I check if 2 quaternions are the same?</b>
 *  Use the == and != operators.
 *
 *  gmtl::Quatf quatA, quatB;
 *  if (quatA == quatB)
 *  {
 *     cout << "Quaternions are equal" << endl;
 *  }
 *  if (quatA != quatB)
 *  {
 *     cout << "Quaternions are not equal" << endl;
 *  }
 *
 *
 *
 *  @subsection Collision Collision and Containment Detection
 *  <b>How do I perform collision detection and containment tests?</b>
 *  GMTL provides various spatial objects, including spheres, line segments, 
 *  rays, points, triangles, planes, axially-aligned bounding boxes, and 
 *  oriented bounding boxes.
 *
 *  The library also provides functions to test whether particular objects
 *  are intersecting each other or whether one object is contained by another.
 *  See below for specific examples.
 *
 *  <b>How do I test if a point is contained by a sphere?</b>
 *  <b>How do I test if a point is on the surface of a sphere?</b>
 *  <b>How do I test if one sphere is contained by another?</b>
 *  <b>How do I test if two spheres intersect while moving?</b>
 *  <b>How do I change a sphere so that it contains a given point?</b>
 *  <b>How do I change a sphere so that it contains a set of points?</b>
 *  <b>How do I change a sphere so that it contains another sphere?</b>
 *  <b>How do I test if two AABoxes intersect?</b>
 *  <b>How do I test if an AABox is contained by another?</b>
 *  <b>How do I test if a point is inside an AABox?</b>
 *  <b>How do I test if two AABoxes intersect while moving?</b>
 *  <b>How do I change an AABox so that it contains a given point?</b>
 *  <b>How do I change an AABox so that it contains another AABox?</b>
 *  <b>How do I change an AABox so that it contains a given sphere?</b>
 *  <b>How do I test if a sphere intersects with an AABox?</b>
 *  <b>How do I test if a ray intersects with a plane?</b>
 *
 *  @subsection General General Math
 *  <b>How do I use GMTL's C math abstraction?</b>
 *
 *  <b>What operations does GMTL's C math abstraction have?</b>
 *  GMTL provides function calls for everything that the standard C math
 *  library has. But they are templated functions, so you don't have to worry
 *  about what data types you are providing for argments.
 *
 *  
 *  <b>What about PI?</b>
 *  There is a floating point value provided for the number Pi. You can 
 *  reference it using 'gmtl::Math::PI'.
 *
 *  There are also constants provided for Pi divided by 2 and Pi divided by 4, 
 *  both of which are commonly used in graphical applications. These additional
 *  values can be referenced by 'gmtl::Math::PI_OVER_2' and
 *  'gmtl::Math::PI_OVER_4'. 
 *
 *
 *  <b>How do I convert from degrees to radians?</b>
 *  Use the deg2Rad function.
 *
 *  float degrees = 90;
 *  float radians = gmtl::Math::deg2Rad( degrees );
 *
 *
 *  <b>How do I convert from radians to degrees?</b>
 *  Use the rad2Deg function.
 *
 *  float radians = 1.57;
 *  float degrees = gmtl::Math::rad2Deg( radians );
 * 
