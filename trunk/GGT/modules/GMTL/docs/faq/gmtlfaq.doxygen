/** @file gmtlfaq.doxygen
  *
  */

/** @mainpage Generic Math Template Library FAQ
 *  Welcome to the GMTL frequently asked questions list.
 *
 *
 * 
 *
 *  @section General General Questions about GMTL
 *
 *  <b>Why do you use templated code?</b>
 *
 *
 *
 *
 *  <b>What's with these namespaces?</b>
 *  
 *
 *
 *
 *  <b>Why would I want to use GMTL's C math abstraction rather than the regular 
 *  C math headers?</b>
 *  
 *
 *
 *
 *  <b>What is an AABox?</b>
 *  This is an axially-aligned bounding box. Think of it as a box in 3D space
 *  with its each of its sides parallel to one of the coordinate axes. Such a
 *  box can be described using only 2 points, the minimum and maximum. AABoxes
 *  can be useful in object collision detection.
 *
 *  <b>What is an AxisAngle?</b>
 *  This is a rotational data type, defined by an arbitrary axis vector in 
 *  space and an amount of rotation. 
 *
 *  <b>What is a Coord?</b>
 *  This is a coordinate frame, defined by a position and a rotation value. 
 *  
 *  <b>What is an EulerAngle?</b>
 *  This is a data type that represents a rotational value. It consists of three
 *  values, each representing a rotation about one of the coordinate axes X, Y,
 *  and Z. Note that Euler angle representations are often more intuitive to
 *  use, but suffer from the problem of Gimble lock.
 *
 *  <b>What is a Matrix?</b>
 *  This is a data type commonly used in graphical applications. It simply
 *  contains rows and columns of data, with any number of rows and columns.
 *  4x4 matrices can represent any transformation in 3D space, containing
 *  (but not limited to) translational, rotational, skew, and scaling 
 *  information.
 *
 *  <b>What is a Plane?</b>
 *  A plane is a flat surface in 3D space with no boundaries. It is defined by
 *  a point in 3D space and a surface normal vector.
 *
 *  <b>What is a Point?</b>
 *  Points represent a position in space, with one data value per dimension of
 *  that space. 
 *
 *  <b>What is a Quat?</b>
 *  This is a quaternion, which is represents a rotation in 3D space.
 *  Quaternions can be used for rotational interpolation along the surface
 *  of a sphere.
 *
 *  <b>What is a Sphere?</b>
 *  This is a 3D dimensional round object such that every point on the outer
 *  boundary of the object is the same distance away from the centerpoint. A
 *  sphere can be described by a centerpoint position and a radius.
 *
 *  <b>What is a Tri?</b>
 *  This is a triangle, defined by three points in space. The counterclockwise
 *  ordering of the points determines the direction of the triangle's surface
 *  normal (using a right-handed coordinate system). 
 *
 *  <b>What is a Vec?</b>
 *  This is a vector that represents a direction in space, with one data value
 *  per dimension of the space.
 *
 *  <b>What is the difference between a point and a vector?</b>
 *  Points represent positions in space, while vectors represent a direction.
 *  Even though they may seem to represent the same data, it is generally 
 *  discouraged to use them interchangably. Differences occur when operations
 *  are performed on them. For instance, if you transform a point using a 
 *  matrix, the full transformation will be applied to the point (translation,
 *  rotation, skew, and scale). But when a vector is transformed by a matrix,
 *  only the rotational transform is applied to it.
 *
 *  <b>Why doesn't my vector move?</b>
 *  If you are transforming a vector using a matrix, only the matrix's 
 *  rotational information will be applied. Hence, you may be expecting the
 *  vector's endpoint to change but it will not. You most likely want to use
 *  a Point object instead of a Vec.
 *
 *  <b>What is the difference between AxisAngle, EulerAngle and Quat?</b>
 *  An axis angle consists of a vector designating the axis to rotate about,
 *  and the rotation amount to use. 
 *  An Euler angle object consists of 3 rotation amounts, one for each
 *  coordinate axis X, Y, and Z. Euler angles are often the most intuitive
 *  rotation type, but suffer from the Gimble lock problem.
 *  A quaternion has 4 values that can be translated into an axis and a
 *  rotation amount, but are stored in a normalized form that maintain the
 *  mathematical properties of quaternions, including the ability of spherical
 *  interpolation.  
 *  
 *  <b>How is data represented in a matrix?</b>
 *  GMTL matrices are represented in the same way that OpenGL represents data
 *  in a matrix, in column major order. 
 *
 *  @section Howto How Do I ...?
 *
 *  @subsection Vectors Vectors
 *  <b>How do I rotate a vector?</b>
 *  <b>How do I find the cross product of 2 vectors?</b>
 *  <b>How do I find the dot product of 2 vectors?</b>
 *  <b>How do I normalize a vector?</b>
 *  <b>How do I find the length of a vector?</b>
 *
 *  @subsection Matrices Matrices
 *  <b>How do I multiply matrices?</b>
 *
 *
 *
 *
 *
 *
 *  <b>How do I create a matrix?</b>
 *
 *
 *
 *
 *
 *
 *  <b>How do I create a matrix from a vector?</b>
 *  Using the makeTrans function, you can create a purely translational matrix 
 *  from a vector. 
 *
 *  gmtl::Vec3f myVec;
 *  gmtl::Matrix44f myMat = gmtl::makeTrans< gmtl::Matrix44f >( myVec );
 *
 *
 *  <b>How do I create a matrix from a point?</b>
 *  Using the make function, you can create a purely translational matrix from a
 *  point. 
 *
 *  gmtl::Point3f myPoint;
 *  gmtl::Matrix44f myMat = gmtl::make< gmtl::Matrix44f >( myPoint );
 *
 *
 *  <b>How do I create a matrix from a quaterion?</b>
 *  Using the make function, you can create a purely rotational matrix from a
 *  quaternion object. 
 *
 *  gmtl::Quatf myQuat;
 *  gmtl::Matrix44f myMat = gmtl::make< gmtl::Matrix44f >( myQuat );
 *
 *
 *  <b>How do I create a matrix from an Euler angle?</b>
 *  Using the make function, you can create a purely rotational matrix from an
 *  EulerAngle object. 
 *
 *  gmtl::EulerAngleXYZf myEulerAngle;
 *  gmtl::Matrix44f myMat = gmtl::make< gmtl::Matrix44f >( myEulerAngle );
 *
 *
 *
 *  <b>How do I create a matrix from an axis angle?</b>
 *  Using the make function, you can create a purely rotational matrix from an
 *  AxisAngle object. 
 *
 *  gmtl::AxisAnglef myAxisAngle;
 *  gmtl::Matrix44f myMat = gmtl::make< gmtl::Matrix44f >( myAxisAngle );
 *
 *
 *  <b>How do I scale a matrix?</b>
 *  gmtl::Matrix44f myMat;
 *  float scale = 0.5;
 *
 *  gmtl::setScale( myMat, scale );
 *
 *
 *
 *
 *
 *  <b>How do I copy a matrix?</b>
 *  You can simply use the '=' operator to copy from one matrix to another.
 * 
 *  gmtl::Matrix44f matA, matB;
 *  matA = matB;
 *
 *
 *  <b>How do I extract just the rotation data from a matrix?</b>
 *  You can extract the rotational data as any of GMTL's rotation data types.
 *  In any case, you need to use the makeRot templated function. Note that you
 *  need to specify which rotation data type you want to extract.
 *
 *  gmtl::Matrix44f myMat;
 *  gmtl::EulerAngleXYZf myEuler;
 *  gmtl::AxisAnglef myAxisAngle;
 *  gmtl::Quatf myQuat;
 *  gmtl::Matrix44f myRotationMat;
 *
 *  myEuler = gmtl::makeRot< gmtl::EulerAngleXYZf >( myMat );
 *  myAxisAngle = gmtl::makeRot< gmtl::AxisAnglef >( myMat );
 *  myQuat = gmtl::makeRot< gmtl::Quatf >( myMat );
 *  myRotationMat = gmtl::makeRot< gmtl::EulerAngleXYZf >( myMat );
 *
 * 
 *  <b>How do I extract just the translation data from a matrix?</b>
 *  You can extract the translational data as either a vector or a point.
 *  You need to use the templated makeTrans function.
 *
 *  gmtl::Matrix44f myMat;
 *  gmtl::Point3f myPoint;
 *  gmtl::Vec3f myVec;
 * 
 *  myVec = gmtl::makeTrans< gmtl::Vec3f >( myMat );
 *  myPoint = gmtl::makeTrans< gmtl::Point3f >( myMat );
 *
 *
 *  <b>How do I extract the scale from a matrix?</b>
 *
 *
 *
 *
 *
 *
 *  <b>How do I set a matrix to be the identity matrix?</b>
 *  Matrices will automatically be identity matrices upon creation. If you
 *  want to set them to the identity later, use the identity function.
 *  
 *  gmtl::Matrix44f myMat;
 *  gmtl::identity( myMat );
 *
 *  <b>How do I set a matrix to contain all zeros?</b>
 *  gmtl::Matrix44f myMat;
 *  gmtl::zero( myMat );
 *
 *  <b>How do I invert a matrix?</b>
 *  In most cases you can simply use the invert function. This will perform a
 *  "smart" inversion that selects an inversion method (full, affine, 
 *  orthonormal, orthogonal, or identity) based on the kinds of transformations
 *  it has been through.
 * 
 *  gmtl::Matrix44f myMat;
 *  gmtl::invert( myMat );
 *
 *  You can optionally force a full inversion by using the invertFull function.
 * 
 *  gmtl::invertFull( myMat );
 *
 * 
 *  <b>How do I transform a point using a matrix?</b>
 *  This will perform a full transformation on the point.
 *
 *  gmtl::Point3f myPoint;
 *  gmtl::Matrix44f myMat;
 *  gmtl::xform( myPoint, myMat, myPoint );
 *
 *
 *  <b>How do I transform a vector using a matrix?</b>
 *  It is important to note that a vector will only be modified by the
 *  rotational transformation contained in a matrix.
 *
 *  gmtl::Vec3f myVec;
 *  gmtl::Matrix44f myMat;
 *  gmtl::xform( myVec, myMat, myVec ); 
 *
 *
 *
 *  <b>How do I use my matrix data with OpenGL?</b>
 *  You can access the raw matrix data for use with OpenGL using the getData()
 *  function.  For instance, you may want to multiply the OpenGL matrix stack
 *  by a GMTL matrix.
 *  
 *  gmtl::Matrix44f myMat;
 *  glMultMatrixf( myMat.getData() );
 *
 *
 *  <b>How do I use my matrix data with DirectX?</b>
 *
 *
 *
 *
 *
 *
 *  @subsection Quaternions Quaternions
 *
 *  @subsection General General Math
 *  <b>How do I use GMTL's C math abstraction?</b>
 *  <b>What operations does GMTL's C math abstraction have?</b>
 *  <b>What about PI?</b>
 *  <b>How do I get the ceiling of a floating point number?</b>

 *  <b>How do I convert from degrees to radians?</b>
 *  float degrees = 90;
 *  float radians = gmtl::Math::deg2Rad( degrees );
 *
 *  <b>How do I convert from radians to degrees?</b>
 *  float radians = 1.57;
 *  float degrees = gmtl::Math::rad2Deg( radians );
 * 
